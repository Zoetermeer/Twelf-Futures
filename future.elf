% Author: James Swaine 
% Small-step semantics for Mini-ML with futures and explicit forcing.
% This supports nested futures.  

% p ::= e (e N) ...   (where N ranges over nats) 

% A thread is an exp * nat pair, where the nat is the future/thread id.
thread 	: type. 			  %name thread T.
mkthread : expr -> nat -> thread. 

% Thread list 
threads : type.         %name threads Ts.
nothreads : threads.
cth : thread -> threads -> threads. % cth = cons threads

% Gives the next available future/thread ID
nextdesc        : threads -> nat -> type. 
%mode nextdesc +Ts -M.
next_empty      : nextdesc nothreads z. 
next_nonempt_z  : nextdesc ((mkthread E z) Ts) (s z). 
next_nonempt_s  : nextdesc ((mkthread E (s M)) Ts) (s M).

% Whether the future has finished evaluation 
% May not really be necessary, since all we need is a 
% premise for V value
tdone           : thread -> exp -> type. 
tdone_v         : tdone (mkthread V M) V 
               <- value V.

% Look up a future in the list 
tlookup         : nat -> threads -> thread -> type. 
tlookup_match   : tlookup M (cth (mkthread E M) Ts) (mkthread E M).
tlookup_recur   : tlookup M (cth (mkthread E M1) Ts) T
               <- tlookup M Ts T 
               <- value M.

% Program representation
prog : type. 						%name prog P.
mkprog : exp -> threads -> prog. 

% Judgments
progstep : prog -> prog -> type. 
%mode progstep +P -P.
estp : expr -> threads -> expr -> threads -> type.
%mode estp +E +T -E' -T'.

progstep_noth   : progstep (mkprog E nothreads) (mkprog E' Ts) 
                <- estp E nothreads E' Ts.
progstep_th     : progstep (mkprog E Ts) (mkprog E' Ts') 
                <- estp E Ts E' Ts'.

% Two sets of inference rules here.  At any given point, 
% we can either choose to continue executing the 'current' thread 
% and move one step in evaluating its current E, 
% or swap in another thread and begin executing there. 
% The first set of rules covers the cases where we continue executing 
% on the 'current' thread.
estp_noth       : estp E nothreads E' nothreads.

% Continue to execute the 'current' thread
estp_cont_s     : estp (s E) Ts (s E') Ts 
               <- estp E Ts E' Ts.
estp_cont_case_z: estp (case z E1 E2) Ts (case z E1' E2) Ts
               <- estp E1 Ts E1' Ts.
estp_cont_case_s: estp (case (s V) E1 E2) Ts (E2 V) 
               <- value V.
estp_cont_app   : estp (app E1 E2) Ts (app E1' E2) Ts 
               <- estp E1 Ts E1' Ts.
estp_cont_fix   : estp (fix E) Ts (E (fix E)) Ts.

% 'future' returns a value (the ID/descriptor of the new future), so the result is M
estp_cont_future: estp (future E) Ts M (cth (mkthread E M) Ts) 
               <- nextdesc Ts M.
estp_cont_touch : estp (touch E) Ts (touch E') Ts' 
               <- estp E Ts E' Ts'
estp_cont_touchv: estp (touch M) Ts V Ts 
               <- value V
               <- tlookup M Ts (mkthread V M)
               <- value M.

% not correct - can't pass Ts to estp in the second premise, because then the future's 
% current E will be treated as the current thread E, but we might choose 
% the same future out of Ts and start executing it instead.  undefined
estp_cont_touchu: estp (touch M) Ts E' Ts'. 
               <- estp E Ts E' Ts'
               <- tlookup M Ts (mkthread E M).


% This set of rules covers the cases when we decide to switch to another thread.
estp_prpt_s     : estp E (cth (mkthread (s E1) M) Ts) E (cth (mkthread (s E1') M) Ts)
               <- estp E1 Ts E1' Ts'.
estp_prpt_case_z: estp E (cth (mkthread (case z E1 E2) M) Ts) E (cth (mkthread (case z E1' E2) M) Ts) 
               <- estp E1 Ts E1' Ts'. 
estp_prpt_case_s: estp E (cth (mkthread (case (s V) E1 E2) M) Ts) E (cth (mkthread (E2 V) M) Ts) 
               <- value V.
estp_prpt_app   : estp E (cth (mkthread (app E1 E2) M) Ts) E (cth (mkthread (app E1' E2) M) Ts) 
               <- estp E1 Ts E1' Ts.
estp_prpt_fix   : estp E (cth (mkthread (fix E) M) Ts) E (cth (mkthread (E (fix E)) M) Ts).
estp_prpt_future: estp E (cth (mkthread (future E) M1) Ts) E (cth (mkthread E M2) (cth (mkthread M2 M1) Ts))
               <- nextdesc Ts M2.
estp_prpt_touch : estp E (cth (mkthread (touch M) M1) Ts) E (cth (mkthread (touch M) M1) (cth (mkthread E1' M) Ts)) 
               <- estp E1 Ts E1' Ts' 
               <- tlookup M Ts (mkthread E1 M).
